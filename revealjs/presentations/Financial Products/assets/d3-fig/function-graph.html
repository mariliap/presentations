<!DOCTYPE html>
<meta charset="utf-8">

<head>
</head>

<style>
  .axisWhite line {
    stroke: white;
  }

  .axisWhite path {
    stroke: white;
  }

  .axisWhite text {
    fill: white;
  }
</style>

<script src="js/d3.v7.min.js"></script>
<script src="line.js"></script>
<body>

  
 <script>
    let funcParams = {
      startPrice: 1000,
      premium: 100,
      strikePrice: 1000
    }

    function calculateCostToBuy(marketPrice) {
      
      let price = marketPrice;
      if (marketPrice > funcParams.strikePrice) {
        price = funcParams.strikePrice;
      }
      let costToBuyNow = (price + funcParams.premium);

      return costToBuyNow;
    }

    function profitComparedToMarketDateNotUsingCallOption(marketPrice) {
      let costToBuyNow = calculateCostToBuy(marketPrice);
      let profitComparedToMarketDate = funcParams.startPrice - marketPrice; //-> estrategia de esperar pra comprar
      return profitComparedToMarketDate;
    }

    function profitComparedToStartDate(marketPrice) {
      let costToBuyNow = calculateCostToBuy(marketPrice);
      let profitComparedToStartDate = funcParams.startPrice - costToBuyNow;//estategia call option em relacao a ter comprado no inicio
      return profitComparedToStartDate;
    }

    function profitComparedToMarketDate(marketPrice) {
      let costToBuyNow = calculateCostToBuy(marketPrice);
      let profitComparedToMarketDate = marketPrice - costToBuyNow;
      //let profitComparedToMarketDate = funcParams.startPrice - marketPrice; -> estrategia de esperar pra comprar
      //let profitComparedToMarketDate = (funcParams.startPrice - costToBuyNow) - (funcParams.startPrice - marketPrice); -> estrategia de esperar pra comprar VS call option
      return profitComparedToMarketDate;
    }

   
    // Convention: https://bl.ocks.org/mbostock/3019563
    const margin = { top: 10, right: 50, bottom: 50, left: 50 }
    const canvasSize = {
      width: 450 - margin.left - margin.right,
      height: 400 - margin.top - margin.bottom
    }

    const xRange = [700, 1300] 
    const yRange = [-300, 300] 
    const colors = ["teal", "pink", "green"]
    const profitFunctions = [
      {
        function: profitComparedToMarketDateNotUsingCallOption,
        color: 'green',
        params: funcParams,
        description: `qual o meu lucro de comprar o ativo hoje (expiry date), 
                      sem a call option, em comparação a se eu NÃO tivesse esperado 
                      pra comprar o ativo (valor inicial = ${funcParams.startPrice})`
      },
      {
        function: profitComparedToStartDate,
        color: 'teal',
        params: funcParams,
        description: `qual o meu lucro de comprar o ativo hoje (expiry date), 
                      com a call option, em comparação a se eu NÃO tivesse esperado 
                      pra comprar o ativo (valor inicial = ${funcParams.startPrice})`
      },
      {
        function: profitComparedToMarketDate,
        color: 'pink',
        params: funcParams,
        description: `qual o meu lucro de comprar o ativo hoje (expiry date), 
                      com a call option, em comparação a se não a tivesse comprado 
                      e tivesse esperado para comprar o ativo (valor a mercado)`
      },
      
    ]
    const areas = [
      {
        id:'area1', 
        color:'yellow', 
        opacity: 0.2,
        x0: xRange[0], 
        x1: funcParams.strikePrice - xRange[0] - funcParams.premium,
        y0: yRange[0],
        y1: yRange[1]
      },
      {
        id:'area2', 
        color:'red', 
        opacity: 0.2,
        x0: funcParams.strikePrice - funcParams.premium, 
        x1: funcParams.premium,
        y0: yRange[0],
        y1: yRange[1]
      },
      {
        id:'area3', 
        color:'red', 
        opacity: 0.2,
        x0: funcParams.strikePrice, 
        x1: funcParams.premium,
        y0: yRange[0],
        y1: yRange[1]
      },
      {
        id:'area4', 
        color:'yellow',
        opacity: 0.2, 
        x0: funcParams.strikePrice + funcParams.premium, 
        x1: xRange[1] - funcParams.strikePrice - funcParams.premium,
        y0: yRange[0],
        y1: yRange[1]
      }
    ]

    const graph = functionGrahph(profitFunctions, funcParams, 
                                 colors, xRange, yRange, canvasSize, areas)
    
    const vlines = {
      x0: funcParams.strikePrice - funcParams.premium - (funcParams.premium/2),
      x1: funcParams.strikePrice - funcParams.premium,
      x2: funcParams.strikePrice - (funcParams.premium/2),
      x3: funcParams.strikePrice,
      x4: funcParams.strikePrice + (funcParams.premium/2),
      x5: funcParams.strikePrice + funcParams.premium,
      x6: funcParams.strikePrice + funcParams.premium + (funcParams.premium/2),
    }
    const vlinesYY = x => [
      yRange[0],
      profitComparedToMarketDateNotUsingCallOption(x),
    ];

    const crossingPoints = {
      getY: x => [
        profitFunctions[0].function(x),
        profitFunctions[1].function(x),
        profitFunctions[2].function(x)
      ],
      colors: [
        profitFunctions[0].color,
        profitFunctions[1].color,
        profitFunctions[2].color
      ]
    };

   
    var _transitions = [
      {
        transitionForward: () => {
          //addArea('area', graph, areas[0].x0, areas[0].x1, 'red', xRange, yRange)
          addVerticalLineAt("vline", graph, vlines.x0, 'black', yRange, crossingPoints)          
        },
        transitionBackward: () => {
          removeElement("vline", graph.svg)
          // removeElement("area", graph.svg)
        },
        index: 1
      },
      {
        transitionForward: () => {
          //addArea('area', graph, areas[1].x0, areas[1].x1, 'red', xRange, yRange)
          addVerticalLineAt("vline", graph, vlines.x1, 'black', yRange, crossingPoints)
        },
        transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x0, 'black', yRange, crossingPoints)          
          //addArea('area', graph, areas[0].x0, areas[0].x1, 'red', xRange, yRange)
        },
        index: 2
      },
      {
        transitionForward: () => {
          addVerticalLineAt("vline", graph, vlines.x2, 'black', yRange, crossingPoints)
        },
        transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x1, 'black', yRange, crossingPoints)
        },          
        index: 3
      },
      {
        transitionForward: () => {
          addVerticalLineAt("vline", graph, vlines.x3, 'black', yRange, crossingPoints)
        },
         transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x2, 'black', yRange, crossingPoints)
         },
        index: 4
      },
      {
        transitionForward: () => {
          addVerticalLineAt("vline", graph, vlines.x4, 'black', yRange, crossingPoints)
        },
         transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x3, 'black', yRange, crossingPoints)
         },
        index: 5
      },
      {
        transitionForward: () => {
          addVerticalLineAt("vline", graph, vlines.x5, 'black', yRange, crossingPoints)
        },
         transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x4, 'black', yRange, crossingPoints)
         },
        index: 6
      },
      {
        transitionForward: () => {
          addVerticalLineAt("vline", graph, vlines.x6, 'black', yRange, crossingPoints)
        },
         transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x5, 'black', yRange, crossingPoints)
         },
        index: 7
      },
      {
        transitionForward: () => {
          removeElement("vline", graph.svg)
        },
         transitionBackward: () => {
          addVerticalLineAt("vline", graph, vlines.x6, 'black', yRange, crossingPoints)
         },
        index: 8
      },
    ]


  </script>
</body>